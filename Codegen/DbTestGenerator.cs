using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Codegen;

[Generator]
public class DbTestGenerator: IIncrementalGenerator
{
    private const string Namespace = "Codegen";
    private const string AttributeName = "DbTestAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeName} : System.Attribute
    {{
    }}
}}";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.generated.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Locate and register generators for all classes marked with the marker attribute
        var testsToGenerate = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsClassWithAttributes(s),
                transform: static (context, _) => GetTestGenerator(context)
            )
            .Where(static c => c is not null)
            .Collect()
            .Combine(context.CompilationProvider);

        context.RegisterSourceOutput(testsToGenerate,
            static (context, pair) =>
            {
                foreach (var generator in pair.Left)
                {
                    generator.Generate(context, pair.Right);
                }
            });
    }

    private static bool IsClassWithAttributes(SyntaxNode syntaxNode)
    {
        return syntaxNode is ClassDeclarationSyntax classNode
               && classNode.AttributeLists
                   .SelectMany(list => list.Attributes).Any();
    }

    private static Generator? GetTestGenerator(GeneratorSyntaxContext context)
    {
        var classNode = context.Node as ClassDeclarationSyntax; // We know this won't fail
        
        var hasAttribute = classNode!.AttributeLists.SelectMany(list => list.Attributes)
            .Select(attribute => context.SemanticModel.GetSymbolInfo(attribute).Symbol)
            .OfType<IMethodSymbol>()
            .Any(symbol => symbol.ContainingType.ToDisplayString().Equals($"{Namespace}.{AttributeName}"));

        return hasAttribute ? new Generator(context) : null;
    }

    private class Generator(GeneratorSyntaxContext gsc)
    {
        private readonly ClassDeclarationSyntax classNode = (ClassDeclarationSyntax)gsc.Node;
        public void Generate(SourceProductionContext spc, Compilation compilation)
        {
            var semanticModel = compilation.GetSemanticModel(classNode.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classNode) is not INamedTypeSymbol classSymbol)
            {
                return;
            }
            
            var @namespace = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classNode.Identifier.Text;
            GenerateCode(spc, @namespace, className, ["Postgres", "MariaDb"]);
        }

        private void GenerateCode(SourceProductionContext spc, string @namespace, string className, IEnumerable<string> providers)
        {
            var code = $@"
// <auto-generated/>

namespace {@namespace};
";
            foreach (var provider in providers)
            {
                code += $"public class {provider}{className}(): {className}<{provider}Engine>(new {provider}Engine()) {{}}\n";
            }
            
            spc.AddSource($"{className}.generated.cs", code);
        }
    }
}